---
import Layout from "../../../layouts/App.astro";
import { Icon } from "astro-icon";
import { getEntry, z } from "astro:content";
import { getDocumentAnswers, updateAnswers } from "@db/document";
import { getSession } from "auth-astro/server";
import crypt from "@utils/crypt";
import QuestionIndex from "@components/QuestionIndex.astro";
import ChangeNameButton from "@components/ChangeNameButton.astro";
import ChangeNameModal from "@components/ChangeNameModal.astro";
import { handleNameChange } from "@utils/document";
import Badge from "@components/Badge.astro";
import pageTitle from "@utils/pageTitle";
import QuestionAction from "@components/QuestionAction.astro";
import Toast from "@components/Toast.astro";
import { DOCUMENT_NAME_CHANGED, ANSWER_UPDATED } from "@utils/toasts";
import type { Answers } from "@type";
import { SESSION_COOKIE } from "@utils/cookies";
import { storeAnswers, getAnswers, deleteSessionDocument } from "@db/session";
import getQuesitons from "@utils/questions";
import isObjectId from "@utils/objectId";
import ErrorList from "@components/ErrorList.astro";

const { documentId: dId, questionId } = Astro.params;
const documentId = String(dId);
const isUserDocumentId = isObjectId(documentId);
const session = await getSession(Astro.request);
const isUserDocument = isUserDocumentId && session;
const ssid = session
  ? session.user?.ssid
  : Astro.cookies.get(SESSION_COOKIE).value;

if (!ssid) {
  console.log("missing ssid");
  return Astro.redirect("/404");
}

if (!isUserDocumentId) {
  const refererUrl = Astro.request.headers.get("referer");

  if (
    !refererUrl ||
    !refererUrl.includes(documentId) ||
    refererUrl.endsWith(documentId)
  ) {
    await deleteSessionDocument(ssid, documentId);
  }
}

let answers: Answers = {},
  docId = documentId,
  draft = false,
  title: string | undefined,
  toast: string | null = null,
  errors: string[] = [];

const questionEntry = await getEntry("questions", String(questionId));

if (!questionEntry) {
  console.log("missing question entry");
  return Astro.redirect("/404");
}

const {
  data: { question: questionContent, info: qinfo, ...fields },
} = questionEntry;

if (isUserDocument) {
  const userId = session.user?.id;

  if (userId) {
    try {
      const document = await getDocumentAnswers(
        documentId,
        userId,
        Object.keys(fields)
      );

      if (document) {
        ({ doc: docId, answers, title, draft } = document);

        if (!draft) {
          return Astro.redirect(`/dokumenty/${documentId}/dokument`);
        }
      }
    } catch {}
  }
} else {
  try {
    const sessionAnswers = await getAnswers(
      ssid,
      documentId,
      Object.keys(fields)
    );

    if (sessionAnswers) {
      answers = sessionAnswers;
    }
  } catch {}
}

if (!Object.keys(answers).length) {
  answers = fields;
}

const document = await getEntry("documents", docId);

if (!document) {
  console.log("missing document");
  return Astro.redirect("/404");
}

const {
  data: { index, title: docuemntTitle, encrypted },
} = document;

const encryptedAnswers =
  encrypted && Object.keys(answers).some((field) => encrypted.includes(field));

if (isUserDocument && encryptedAnswers) {
  encrypted.forEach((key) => {
    try {
      answers[key] = crypt.decrypt(answers[key]);
    } catch {}
  });
}

if (!title) title = docuemntTitle;

if (!index) {
  console.log("missing index");
  return Astro.redirect("/404");
}

const { questionIndex, questionEntries } = await getQuesitons(index);
const q = questionEntries.find(({ slug }) => slug === questionId);

if (!q) {
  console.log("missing question");
  return Astro.redirect("/404");
}

const currentQuestionIndex = questionIndex.findIndex(
  ({ id: { slug } }) => slug === questionId
);

const qTitle = questionIndex[currentQuestionIndex].title;

const prevUrl =
  currentQuestionIndex > 0
    ? `${Astro.url.origin}/dokumenty/${documentId}/${
        questionIndex[currentQuestionIndex - 1].id.slug
      }`
    : null;
const nextUrl = `${Astro.url.origin}/dokumenty/${documentId}/${
  currentQuestionIndex < questionIndex.length - 1
    ? `${questionIndex[currentQuestionIndex + 1].id.slug}`
    : `podsumowanie`
}`;

if (Astro.request.method === "POST") {
  const formData = await Astro.request.formData();
  const newTitle = formData.get("title");

  if (newTitle && isUserDocument) {
    try {
      await handleNameChange(formData);

      title = String(newTitle);
      toast = DOCUMENT_NAME_CHANGED;
    } catch {}
  }

  if (formData && !newTitle) {
    try {
      let newAnswers: Answers = {};

      for (let [key, value] of formData.entries()) {
        if (key in answers && value !== String(answers[key])) {
          Object.assign(newAnswers, { [key]: value });
        }
      }

      if (isUserDocumentId) {
        if (Object.keys(newAnswers).length) {
          if (encryptedAnswers) {
            encrypted.forEach((key) => {
              if (newAnswers[key] && newAnswers[key].length) {
                try {
                  newAnswers[key] = crypt.encrypt(newAnswers[key]);
                } catch {}
              }
            });
          }

          try {
            await updateAnswers(documentId, newAnswers, docId);
            toast = ANSWER_UPDATED;
          } catch (e) {
            if (e instanceof z.ZodError) {
              e.errors.map(({ message }) => errors.push(message));
            }
          } finally {
            answers = { ...answers, ...newAnswers };
          }
        }
      } else {
        try {
          if (Object.keys(newAnswers).length) {
            await storeAnswers(ssid, documentId, newAnswers);
            return Astro.redirect(nextUrl);
          }
        } catch (e) {
          // console.log(e);
          if (e instanceof z.ZodError) {
            e.errors.map(({ message }) => errors.push(message));
          }
        } finally {
          answers = { ...answers, ...newAnswers };
        }
      }
    } catch (error) {
      if (error instanceof Error) {
        console.error(error.message);
      }
      return Astro.redirect("/404");
    }
  }
}

const { remarkPluginFrontmatter: qData, Content } = await q.render();

for (let key of Object.keys(qData)) {
  if (key in fields) {
    if (answers[key]) {
      qData[key] = answers[key];
    } else {
      qData[key] = fields[key];
    }
  }
}
---

<Layout title={pageTitle(`${qTitle} - ${title}`)}>
  <span slot="topbar-title"
    ><span>{title}</span>{draft && <Badge>Szkic</Badge>}</span
  >
  {
    draft && (
      <ChangeNameButton
        id={documentId}
        title={title}
        slot="topbar-after-title"
      />
    )
  }
  <QuestionAction
    slot="topbar-aside"
    current={currentQuestionIndex + 1}
    steps={questionIndex.length}
    docId={docId}
    draft={draft}
  />
  <question-form>
    <form method="POST">
      <header>
        <h2>{questionContent}</h2>
        {
          qinfo && (
            <p>
              <Icon name="bulb" width={24} height={24} />
              {qinfo}
            </p>
          )
        }
      </header>
      {
        errors.length ? (
          <ErrorList>
            {errors.map((message) => (
              <p>{message}</p>
            ))}
          </ErrorList>
        ) : (
          ``
        )
      }
      <Content />
      <footer>
        <div>
          <span>§{currentQuestionIndex + 1}</span>
          <span>{qTitle}</span>
        </div>
        <nav>
          {
            draft ? (
              <>
                <a
                  href={`${Astro.url.origin}/dokumenty/${documentId}/podsumowanie`}
                >
                  Wróć do podsumowania
                </a>
                <button type="submit" disabled>
                  Zapisz zmiany
                </button>
              </>
            ) : (
              <>
                {prevUrl && <a href={prevUrl}>Poprzednie</a>}
                <button type="submit">
                  {currentQuestionIndex >= questionIndex.length - 1
                    ? "Podsumowanie"
                    : "Następne"}
                </button>
              </>
            )
          }
        </nav>
      </footer>
    </form>
  </question-form>
  {
    index && questionId && (
      <QuestionIndex
        index={index}
        current={questionId}
        documentId={documentId}
        documentTitle={docuemntTitle}
      />
    )
  }
  {draft && <ChangeNameModal />}
  {toast && <Toast info={toast} />}
</Layout>

<style>
  question-form {
    @apply w-full max-w-[780px] mx-auto;
    @apply flex flex-col justify-center min-h-full;
    @apply py-[var(--navbar-height)];
  }

  form {
    @apply flex flex-col gap-20;
  }

  form :global(fieldset) {
    @apply flex flex-col gap-20;
  }

  footer {
    @apply flex flex-wrap gap-10;
    @apply justify-between;
    @apply my-30;
  }

  footer div {
    @apply hidden md:flex gap-10 items-center;
  }

  footer div > span:first-child {
    @apply px-[8px] py-[4px] bg-dark10 rounded-sm text-xs font-bold;
  }

  footer nav {
    @apply flex flex-wrap gap-15;
  }

  footer a {
    @apply btn btn-alt btn-big;
  }

  footer button[type="submit"] {
    @apply btn btn-default btn-big;
    @apply self-end;
  }

  header p {
    @apply bg-white border-dark55 border-2 rounded-xl;
    @apply p-20;
    @apply flex gap-15;
    @apply font-serif italic text-dark90;
    @apply my-20;
  }

  header p svg {
    @apply flex-shrink-0;
    @apply text-orangeDark;
  }
</style>

<script>
  class QuestionForm extends HTMLElement {
    form: HTMLFormElement | null;
    submit: HTMLButtonElement | null;

    constructor() {
      super();

      this.form = this.querySelector("form");
      this.submit = this.form
        ? this.form.querySelector("button[type='submit']")
        : null;
    }

    connectedCallback() {
      if (this.form) {
        this.form.addEventListener("input", () => {
          if (this.submit) {
            this.submit.removeAttribute("disabled");
          }
        });
      }
    }
  }
  customElements.define("question-form", QuestionForm);
</script>
