---
import Layout from "../../../layouts/App.astro";
import { Icon } from "astro-icon";
import { getEntry } from "astro:content";
import { getSession } from "auth-astro/server";
import QuestionIndex from "@components/QuestionIndex.astro";
import ChangeNameButton from "@components/ChangeNameButton.astro";
import ChangeNameModal from "@components/ChangeNameModal.astro";
import Badge from "@components/Badge.astro";
import pageTitle from "@utils/pageTitle";
import QuestionAction from "@components/QuestionAction.astro";
import Toast from "@components/Toast.astro";
import {
  DOCUMENT_NAME_CHANGED,
  ANSWER_UPDATED,
  DOCUMENT_NAME_PARAM,
  ANSWER_UPDATED_PARAM,
  ERROR_PARAM,
  ToastStatus,
  ERROR,
} from "@utils/toasts";
import type { Answers, Question } from "@type";
import { SESSION_COOKIE } from "@utils/cookies";
import { deleteSessionDocument } from "@db/session";
import ErrorList from "@components/ErrorList.astro";
import { UUID } from "mongodb";
import routes from "@utils/routes";
import { REDIRECT } from "@utils/urlParams";
import { changeDocumentName, postAnswers } from "@api/documents";
import { getQuestion } from "@api/templates";

const { documentId, questionId } = Astro.params as {
  documentId: string;
  questionId: string;
};

let answers: Answers = {},
  qData: Answers = {},
  Content,
  templateId = documentId as string,
  draft: Question["draft"] = false,
  question: Question["question"] = "",
  info: Question["info"],
  documentTitle: Question["documentTitle"] = "",
  index: Question["index"] = [],
  prevId: Question["prevId"],
  nextId: Question["nextId"] = routes.SUMMARY,
  currentQuestionIndex: Question["currentQuestionIndex"] = 0,
  questionShort: Question["questionShort"],
  questionIndex: Question["questionIndex"] = 0,
  prevUrl: string | null = null,
  nextUrl: string | null = null,
  toast: string | null = null,
  toastStatus: ToastStatus = ToastStatus.default,
  errors: string[] = [];

const cookie = `${Astro.request.headers.get("cookie")}`;

// Check for user session
const session = await getSession(Astro.request);
const ssid = session
  ? session.user?.ssid
  : Astro.cookies.get(SESSION_COOKIE).value;

if (!ssid) {
  return Astro.redirect(routes.NOT_FOUND);
}

// Delete template user session when user navigated outside template
const isUserDocument = UUID.isValid(documentId);

if (!isUserDocument) {
  const refererUrl = Astro.request.headers.get("referer");

  if (
    !refererUrl ||
    !refererUrl.includes(documentId) ||
    refererUrl.endsWith(documentId)
  ) {
    await deleteSessionDocument(ssid, documentId);
  }
}

// get data
try {
  // get question data
  ({
    documentTitle,
    templateId,
    draft,
    index,
    prevId,
    nextId,
    question,
    questionShort,
    info,
    answers,
    currentQuestionIndex,
    questionIndex,
  } = await getQuestion(cookie, documentId, questionId));

  const questionEntry = await getEntry("questions", questionId as string);

  if (!questionEntry) {
    throw new Error(undefined, { cause: 500 });
  }

  ({ remarkPluginFrontmatter: qData, Content } = await questionEntry.render());

  // replace default answers in mdx
  for (let key of Object.keys(qData)) {
    qData[key] = answers[key];
  }

  // // get next/prev links
  prevUrl = prevId
    ? `${Astro.url.origin}${routes.DOCUMENTS}/${documentId}/${prevId}`
    : null;

  nextUrl = `${Astro.url.origin}${routes.DOCUMENTS}/${documentId}${
    nextId ?? routes.SUMMARY
  }`;
} catch (e) {
  if (e instanceof Error) {
    switch (e.cause) {
      case 403:
        return Astro.redirect(
          `${routes.SIGN_IN}?${REDIRECT}=${Astro.url.pathname}`
        );
      case 303:
        return Astro.redirect(
          `${routes.DOCUMENTS}/${documentId}/${routes.DOCUMENT}`
        );
      default:
        return Astro.redirect(routes.NOT_FOUND);
    }
  }
}

// show toast
const urlParams = new URL(Astro.request.url).searchParams;

if (urlParams.has(DOCUMENT_NAME_PARAM)) {
  toast = DOCUMENT_NAME_CHANGED;
  toastStatus = ToastStatus.default;
}

if (urlParams.has(ANSWER_UPDATED_PARAM)) {
  toast = ANSWER_UPDATED;
  toastStatus = ToastStatus.default;
}

if (urlParams.has(ERROR_PARAM)) {
  toast = ERROR;
  toastStatus = ToastStatus.error;
}

// post answers
if (Astro.request.method === "POST") {
  const formData = await Astro.request.formData();
  const newTitle = formData.get("title");

  if (newTitle && isUserDocument) {
    const docId = String(formData.get("template"));
    const redirectUrl = new URL(Astro.request.url);

    try {
      await changeDocumentName(
        `${Astro.request.headers.get("cookie")}`,
        docId,
        newTitle as string
      );

      redirectUrl.searchParams.delete(ANSWER_UPDATED_PARAM);
      redirectUrl.searchParams.set(DOCUMENT_NAME_PARAM, "true");
    } catch {
      redirectUrl.searchParams.set(ERROR_PARAM, "true");
    } finally {
      return Astro.redirect(redirectUrl);
    }
  }

  if (formData && !newTitle) {
    let newAnswers: Answers = {};

    for (let [key, value] of formData.entries()) {
      if (key in answers && value && value !== String(answers[key])) {
        Object.assign(newAnswers, { [key]: value });
      }
    }

    if (Object.keys(newAnswers).length) {
      try {
        await postAnswers(cookie, documentId, newAnswers);

        if (isUserDocument) {
          const redirectUrl = new URL(Astro.request.url);

          redirectUrl.searchParams.delete(DOCUMENT_NAME_PARAM);

          if (!redirectUrl.searchParams.has(ANSWER_UPDATED_PARAM)) {
            redirectUrl.searchParams.append(ANSWER_UPDATED_PARAM, "true");
          }

          return Astro.redirect(redirectUrl);
        }

        return Astro.redirect(nextUrl);
      } catch (e) {
        if (e instanceof Error) {
          if (e.cause === 400) {
            e.message.split(",").forEach((error) => errors.push(error));
          }
        }
      } finally {
        answers = { ...answers, ...newAnswers };

        for (let key of Object.keys(qData)) {
          qData[key] = answers[key];
        }
      }
    } else {
      return Astro.redirect(nextUrl);
    }
  }
}
---

<Layout title={pageTitle(`${questionShort} - ${documentTitle}`)}>
  <span slot="topbar-title">
    <span>{documentTitle}</span><Badge>Szkic</Badge>
  </span>
  {
    isUserDocument && (
      <ChangeNameButton
        id={documentId}
        title={documentTitle}
        slot="topbar-after-title"
      />
    )
  }
  <QuestionAction
    slot="topbar-aside"
    current={currentQuestionIndex + 1}
    steps={questionIndex}
    docId={templateId}
    draft={draft}
  />
  <question-form>
    <form method="POST">
      <header>
        <h2>{question}</h2>
        {
          info && (
            <p>
              <Icon name="bulb" width={24} height={24} />
              {info}
            </p>
          )
        }
      </header>
      {
        errors.length ? (
          <ErrorList>
            {errors.map((message) => (
              <p>{message}</p>
            ))}
          </ErrorList>
        ) : (
          ``
        )
      }
      {Content && <Content />}
      <footer>
        <div>
          <span>§{currentQuestionIndex + 1}</span>
          {questionShort && <span>{questionShort}</span>}
        </div>
        <nav>
          {
            isUserDocument ? (
              <>
                <a
                  href={`${Astro.url.origin}${routes.DOCUMENTS}/${documentId}${routes.SUMMARY}`}
                >
                  Wróć do podsumowania
                </a>
                <button type="submit" disabled>
                  Zapisz zmiany
                </button>
              </>
            ) : (
              <>
                {prevUrl && <a href={prevUrl}>Poprzednie</a>}
                <button type="submit">
                  {currentQuestionIndex >= questionIndex - 1
                    ? "Podsumowanie"
                    : "Następne"}
                </button>
              </>
            )
          }
        </nav>
      </footer>
    </form>
  </question-form>
  {
    index && questionId && (
      <QuestionIndex
        index={index}
        current={questionId}
        documentId={documentId}
        documentTitle={documentTitle}
      />
    )
  }
  {draft && <ChangeNameModal />}
  {toast && <Toast info={toast} status={toastStatus} />}
</Layout>

<style>
  question-form {
    @apply w-full max-w-[780px] mx-auto;
    @apply flex flex-col justify-center min-h-full;
    @apply py-[var(--navbar-height)];
  }

  form {
    @apply flex flex-col gap-20;
  }

  form :global(fieldset) {
    @apply flex flex-col gap-20;
  }

  footer {
    @apply flex flex-wrap gap-10;
    @apply justify-between;
    @apply my-30;
  }

  footer div {
    @apply hidden md:flex gap-10 items-center;
  }

  footer div > span:first-child {
    @apply px-[8px] py-[4px] bg-dark10 rounded-sm text-xs font-bold;
  }

  footer nav {
    @apply flex flex-wrap gap-15;
  }

  footer a {
    @apply btn btn-alt btn-big;
  }

  footer button[type="submit"] {
    @apply btn btn-default btn-big;
    @apply self-end;
  }

  header p {
    @apply bg-white border-dark55 border-2 rounded-xl;
    @apply p-20;
    @apply flex gap-15;
    @apply font-serif italic text-dark90;
    @apply my-20;
  }

  header p svg {
    @apply flex-shrink-0;
    @apply text-orangeDark;
  }
</style>

<script>
  import "@wc/QuestionForm";
</script>
